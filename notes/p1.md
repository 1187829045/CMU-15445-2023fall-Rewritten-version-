page Directory是数据库文件中page id 到page位置的映射，我们对pageDirectory所做的改变必须持久化，所有变更必须记录到磁盘，重启后可以让 DBMS 找的page。

page table是buffer池frame到硬盘page的映射，这不需要保存到磁盘上。是一种在内存中的、临时的映射表，无需在磁盘中备份。

关于实现：不用持久化，我们可以使用hashmap或hashtable实现。

但是我们必须保障是线程安全的，不用持久化。

补充：线程安全意味着两个线程不能同时修改同一个对象，从而使系统处于不一致状态。也就是说，在遍历字典时不能修改字典。

接下来讨论如何为buffer池分配内存。分为全局策略和局部策略。大多数系统会同时尝试两种优化。

全局策略：为数据库系统整体考虑。

局部策略：为具体的查询或者事物考虑。

仅仅需要找到最近最少使用的page，将其移除即可。但是这种策略对某个特定的查询来说可能会很糟糕。


### 多缓冲池

我们可以分配多块内存区域，构造多个buffer池。让每个表都有一个buffer池。在每个buffer池上使用局部策略。这样就可以为你放入的数据量身定制，选择最好的局部策略。

例如，有些表需要进行一系列的循环扫描。还可以减少 latch 竞争，改善局部性。

这意味着我会遇到多个线程争抢同一个latch的情况，他们会访问同一个page表，这就会导致多核处理器没法完全利用性能。因为关键部分会有争抢。

即现在的多buffer pool解决方案。

这样就大大的减少latch竞争，虽然现在的根本原因是磁盘是瓶颈，但这样至少我们不再担心latch竞争这种情况的出现。

### 预读取、mmap

下一步我们能做的优化是预读取，操作系统就可以帮助我们实现这种预读取处理。用mmap

### 扫描共享

通俗的理解为搭别人的顺风车。复用从磁盘中获取的数据用于其他查询。这和结果缓存（result caching）效果相同。通俗理解：你办事情，我在结束的地方等你，等你办好，我也用你的结果，然后去办自己的事情。

### 游标共享：Oracle支持的，基于扫描共享的技术

Oracle支持一种基本的扫描共享(Scan sharing)技术，他们称之为游标共享(Cursor sharing)，但只有当你有两个查询在同一时刻执行时，它才会有效

### Buffer Pool Bypass（缓冲池绕过）

当遇到扫描量非常大的查询时，如果将所需的 pages 从磁盘中一个一个的换入 Buffer Pool，将会造成buffer池的污染，因为这些 pages 通常只使用一次，而它们的进入将导致一些可能在未来更需要的 pages 被移除，因此一些 DBMS 做了相应的优化。

思路：分配一小块内存给那个线程，当他从磁盘中读取page时，不管这个page已经在buffer池中了还是不在，都要放在这一小块另开辟的内存中，当查询完成时就会释放掉这块内存，这样不会污染buffer池。

### 操作系统page缓存

数据库系统有缓冲池，操作系统也有硬盘与内存之间的缓存策略，这会导致一份数据（一份磁盘page）分别在操作系统和 DMBS 中的缓冲池被缓存两次。因此大多数 DBMS 都会使用 (O_DIRECT) 来告诉操作系统不要缓存这些数据，Postgres是主流数据库中唯一使用了操作系统page缓存得数据库。

### 为什么这样做？

因为我们数据库缓冲池中有一份副本，而操作系统也缓存了一份磁盘page副本，在我们更新数据库缓冲池中的page后，操作系统缓存的那份page就是旧的，这显然是一份多余的数据。作为数据库系统，我们希望自主管理我们的page，不想让操作系统掺和。

另外，不同操作系统的page缓存策略也是不同的，同一种数据库有linux也有Windows版本，为了保证跨操作系统之间的一致性，这也需要数据库自己本身来管理一切。

### 替换策略

当缓冲池空间不足时，读入新的 pages 之前必然需要 DBMS 从缓冲池中移除一些pages。这与操作系统中的置换算法差不多。
因为那些高端数据库拥有非常复杂的替换策略，会去统计page相关使用数据以便做出最好的决策。但也并不是说开源数据库和一些较新的数据库的替换策略很糟糕，这里只是相对的。下面讲一个非常简单的技术。

#### LRU（最近最久未使用算法）

基本思想就是追踪最后被访问的时间戳，我们仅需去看哪个时间戳最老，将其置换出去即可。

具体实现方面，操作系统页面置换LRU算法提到了使用栈来解决，当然这里也可以使用队列来实现，如果有人读写了这个page就将其从队列中剔除然后放在尾部，头部的page会被一个个换出。

#### Clock（时钟置换算法，项目中需要实现）

Clock是LRU的一种近似算法，无需追踪时间戳而是追踪标志位（这一部分在操作系统中页面置换算法里也讲过，可以回顾参考）。


思路：最开始，被换入的内存中的page标志位都是0，一旦被访问了就将其标志位置为1。

当需要换出时，就像一个钟表一样顺时针或者逆时针旋转，如果发现指向的这个page标志位为1就将它改为0，然后旋转，发现标志位是0的下一个page，就将其换出。


这种算法之所以是LRU的近似算法是因为LRU算法记录了最久，是单纯的按照时间来决定换出的。但是Clock算法（时间片轮转调度算法）的时间窗是固定的，重点关注是“未使用”。

缺点：Clock算法的缺点是sequential flooding（顺序洪水）问题。执行某种特殊的操作时会连续的将page换入，这会导致我们需要的page被从缓冲池中移除掉。——这一部分跟上面Buffer Pool Bypass遇到的问题一样。

#### LRU-K

其中K是指需要对于单个page对应缓存数据的访问进行计数的次数

将数据的访问记录策略从仅记录最近一次访问扩展为记录最近访问的次数。当某个数据的访问次数达到预定的阈值（K次）时，该数据的索引将从历史队列中移除，并重新组织到缓冲区中。

越复杂的数据库系统可能采用这种方法，MYSQL可能就是，——Andy老师上课说的。

#### 多缓冲池

这里并不是将我所扫描的这张表放入全部的缓冲池中。而是各说各的事 ，会移除对我而言最近最少使用的那个page，而不是以全局角度。

#### 优先级提示

有时候 DBMS 知道每个 page 在查询执行过程中的上下文信息，因此它可以根据这些信息判断一个 page 是被保留还是移除。——这比操作系统page置换策略“聪明的多”

#### 脏页

脏页其实就是缓冲池中被修改过的page，它需要写回到磁盘page中。

这里我们讨论的是脏页刷新策略。我们知道移除一个脏页的成本要高于移除一般 page，因为前者需要写回到磁盘中，后者可以直接 drop掉。

当我需要从缓存池中移除page时，最快的方法就是找到一个未被标记脏页的page将其移出，将一个新的frame放入缓冲池中

为了避免必须立即将缓冲池的page换出以腾出空间的问题，除了直接在置换策略中考虑到，有的 DBMS 使用 后台写 的方式来处理这个问题，它们定期扫描 page table，发现 脏页就写入 磁盘，这样在置换时就无需考虑脏数据带来的问题。

因此，数据库系统中会有一个定时执行任务的线程。在平时，这个进程会去缓冲池中寻找脏页将他们写出到磁盘上，然后再将这些page标记为干净的，这样当遇到置换策略需要将其换出时就可以直接drop掉。后面还要考虑到日志、顺序、完整性问题，这些问题的解决都需要考虑到置换策略可能会带来的负影响，这也是数据库系统不想用操作系统mmap的原因，操作系统mmap无法做到。

