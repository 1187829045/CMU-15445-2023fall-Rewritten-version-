page Directory是数据库文件中page id 到page位置的映射，我们对pageDirectory所做的改变必须持久化，所有变更必须记录到磁盘，重启后可以让 DBMS 找的page。

page table是buffer池frame到硬盘page的映射，这不需要保存到磁盘上。是一种在内存中的、临时的映射表，无需在磁盘中备份。

关于实现：不用持久化，我们可以使用hashmap或hashtable实现。

但是我们必须保障是线程安全的，不用持久化。

补充：线程安全意味着两个线程不能同时修改同一个对象，从而使系统处于不一致状态。也就是说，在遍历字典时不能修改字典。

接下来讨论如何为buffer池分配内存。分为全局策略和局部策略。大多数系统会同时尝试两种优化。

全局策略：为数据库系统整体考虑。

局部策略：为具体的查询或者事物考虑。

仅仅需要找到最近最少使用的page，将其移除即可。但是这种策略对某个特定的查询来说可能会很糟糕。


### 多缓冲池

我们可以分配多块内存区域，构造多个buffer池。让每个表都有一个buffer池。在每个buffer池上使用局部策略。这样就可以为你放入的数据量身定制，选择最好的局部策略。

例如，有些表需要进行一系列的循环扫描。还可以减少 latch 竞争，改善局部性。

这意味着我会遇到多个线程争抢同一个latch的情况，他们会访问同一个page表，这就会导致多核处理器没法完全利用性能。因为关键部分会有争抢。

即现在的多buffer pool解决方案。

这样就大大的减少latch竞争，虽然现在的根本原因是磁盘是瓶颈，但这样至少我们不再担心latch竞争这种情况的出现。

### 预读取、mmap

下一步我们能做的优化是预读取，操作系统就可以帮助我们实现这种预读取处理。用mmap

### 扫描共享

通俗的理解为搭别人的顺风车。复用从磁盘中获取的数据用于其他查询。这和结果缓存（result caching）效果相同。通俗理解：你办事情，我在结束的地方等你，等你办好，我也用你的结果，然后去办自己的事情。

### 游标共享：Oracle支持的，基于扫描共享的技术

Oracle支持一种基本的扫描共享(Scan sharing)技术，他们称之为游标共享(Cursor sharing)，但只有当你有两个查询在同一时刻执行时，它才会有效

### Buffer Pool Bypass（缓冲池绕过）

当遇到扫描量非常大的查询时，如果将所需的 pages 从磁盘中一个一个的换入 Buffer Pool，将会造成buffer池的污染，因为这些 pages 通常只使用一次，而它们的进入将导致一些可能在未来更需要的 pages 被移除，因此一些 DBMS 做了相应的优化。

思路：分配一小块内存给那个线程，当他从磁盘中读取page时，不管这个page已经在buffer池中了还是不在，都要放在这一小块另开辟的内存中，当查询完成时就会释放掉这块内存，这样不会污染buffer池。

### 操作系统page缓存

数据库系统有缓冲池，操作系统也有硬盘与内存之间的缓存策略，这会导致一份数据（一份磁盘page）分别在操作系统和 DMBS 中的缓冲池被缓存两次。因此大多数 DBMS 都会使用 (O_DIRECT) 来告诉操作系统不要缓存这些数据，Postgres是主流数据库中唯一使用了操作系统page缓存得数据库。

### 为什么这样做？

因为我们数据库缓冲池中有一份副本，而操作系统也缓存了一份磁盘page副本，在我们更新数据库缓冲池中的page后，操作系统缓存的那份page就是旧的，这显然是一份多余的数据。作为数据库系统，我们希望自主管理我们的page，不想让操作系统掺和。

另外，不同操作系统的page缓存策略也是不同的，同一种数据库有linux也有Windows版本，为了保证跨操作系统之间的一致性，这也需要数据库自己本身来管理一切。

### 替换策略

当缓冲池空间不足时，读入新的 pages 之前必然需要 DBMS 从缓冲池中移除一些pages。这与操作系统中的置换算法差不多。
因为那些高端数据库拥有非常复杂的替换策略，会去统计page相关使用数据以便做出最好的决策。但也并不是说开源数据库和一些较新的数据库的替换策略很糟糕，这里只是相对的。下面讲一个非常简单的技术。

#### LRU（最近最久未使用算法）

基本思想就是追踪最后被访问的时间戳，我们仅需去看哪个时间戳最老，将其置换出去即可。

具体实现方面，操作系统页面置换LRU算法提到了使用栈来解决，当然这里也可以使用队列来实现，如果有人读写了这个page就将其从队列中剔除然后放在尾部，头部的page会被一个个换出。

#### Clock（时钟置换算法，项目中需要实现）

Clock是LRU的一种近似算法，无需追踪时间戳而是追踪标志位（这一部分在操作系统中页面置换算法里也讲过，可以回顾参考）。


思路：最开始，被换入的内存中的page标志位都是0，一旦被访问了就将其标志位置为1。

当需要换出时，就像一个钟表一样顺时针或者逆时针旋转，如果发现指向的这个page标志位为1就将它改为0，然后旋转，发现标志位是0的下一个page，就将其换出。


这种算法之所以是LRU的近似算法是因为LRU算法记录了最久，是单纯的按照时间来决定换出的。但是Clock算法（时间片轮转调度算法）的时间窗是固定的，重点关注是“未使用”。

缺点：Clock算法的缺点是sequential flooding（顺序洪水）问题。执行某种特殊的操作时会连续的将page换入，这会导致我们需要的page被从缓冲池中移除掉。——这一部分跟上面Buffer Pool Bypass遇到的问题一样。

#### LRU-K

其中K是指需要对于单个page对应缓存数据的访问进行计数的次数

将数据的访问记录策略从仅记录最近一次访问扩展为记录最近访问的次数。当某个数据的访问次数达到预定的阈值（K次）时，该数据的索引将从历史队列中移除，并重新组织到缓冲区中。

越复杂的数据库系统可能采用这种方法，MYSQL可能就是，——Andy老师上课说的。

#### 多缓冲池

这里并不是将我所扫描的这张表放入全部的缓冲池中。而是各说各的事 ，会移除对我而言最近最少使用的那个page，而不是以全局角度。

#### 优先级提示

有时候 DBMS 知道每个 page 在查询执行过程中的上下文信息，因此它可以根据这些信息判断一个 page 是被保留还是移除。——这比操作系统page置换策略“聪明的多”

#### 脏页

脏页其实就是缓冲池中被修改过的page，它需要写回到磁盘page中。

这里我们讨论的是脏页刷新策略。我们知道移除一个脏页的成本要高于移除一般 page，因为前者需要写回到磁盘中，后者可以直接 drop掉。

当我需要从缓存池中移除page时，最快的方法就是找到一个未被标记脏页的page将其移出，将一个新的frame放入缓冲池中

为了避免必须立即将缓冲池的page换出以腾出空间的问题，除了直接在置换策略中考虑到，有的 DBMS 使用 后台写 的方式来处理这个问题，它们定期扫描 page table，发现 脏页就写入 磁盘，这样在置换时就无需考虑脏数据带来的问题。

因此，数据库系统中会有一个定时执行任务的线程。在平时，这个进程会去缓冲池中寻找脏页将他们写出到磁盘上，然后再将这些page标记为干净的，这样当遇到置换策略需要将其换出时就可以直接drop掉。后面还要考虑到日志、顺序、完整性问题，这些问题的解决都需要考虑到置换策略可能会带来的负影响，这也是数据库系统不想用操作系统mmap的原因，操作系统mmap无法做到。


## Task1

实现 LRU-K 替换策略

LRU-K 算法逐出一个frames，该frames的后退 k 距离是替换器中所有frames的最大值。向后 k 距离计算为当前时间戳与前 k 次访问的时间戳之间的时间差。历史访问次数少于 k 的frames被赋予 +inf 作为其后退 k 距离。当多个frames具有 +inf 向后 k 距离时，替换器将逐出具有最早总时间戳的frames（即，其最近记录的访问的frames是所有frames中总体上最不新的访问）

LRUKReplacer 的最大大小与缓冲池的大小相同，因为它包含 BufferPoolManager 中所有frames的占位符。但是，在任何给定时刻，并非替换器中的所有frames都被视为可逐出。LRUKReplacer 的大小由可逐出frames的数量表示。LRUKReplacer 已初始化为其中没有frames。然后，只有当frames被标记为可逐出时，替换器的大小才会增加。

DBMS 启动时会使用malloc申请一片内存区域，我们将这段内存区域分成一个个固定大小的chunk并将这块区域划分成大小相同的 pages，为了与 disk pages 区别，通常称为 frames。

首先Evict方法

1.首先加锁，2.然后判断可移除页是不是空，空直接返回false，3.遍历可以移除的页，若是有页的访问次数为0，直接移除，若是有的页访问次数小于k
那么应该优先移除小于k中最早的时间那个页，若没有小于k的则移除最早时间那个页

RecordAccess

首先加锁，然后看该页ID是否存在不存在就创建然后初始化，然后插入node_store

否则，找到该页判断是否达到访问次数的k_达到的话移除最前的时间，加入该访问时间，没有的话直接push

SetEvictable

首先判断该页存不存再，不存在就创建再修改它，存在就修改，如果原本是可驱逐改为不可驱逐，curr_size--,原本不可驱逐，可驱逐，就++


Remove

查找该页是否存在，不存在就返回，存在就移除

## Task2

Diskscheduler类的构造函数中启动了一个线程，用于接收BufferPoolManager发来的读写磁盘请求，并将其放入一个请求队列（request_queue_）中；然后启动一个新线程(background_thread_)，不断从请求队列中获取请求，根据请求类型调用对应DiskManager的读写函数进行磁盘读写。

Schedule(DiskRequest r)：接收请求并放入请求队列
StartWorkerThread()：线程函数，从请求队列中获取新请求，并根据请求类型调用磁盘读写函数
读写的内容在Channel里（已经写好了，直接用就行），注意读写完成之后要给promise类型的那个记录变量赋值（callback_），在下一个task中就能发现promise的作用。

## Task3
系统中的所有内存页面都由 Page 对象表示。

每个 Page 对象包含一个内存块，DiskManager 将使用该位置来复制从磁盘读取的物理页面的内容。

缓冲池管理器将重用相同的 Page 对象来存储数据，因为它在磁盘之间移动。这意味着相同的 Page 对象可能在系统的生命周期中包含不同的物理页面。Page 对象的标识符（page_id）用于跟踪它包含的物理页面；如果 Page 对象不包含物理页面，则其 page_id 必须设置为 INVALID_PAGE_ID。

每个 Page 对象还维护一个线程数计数器，该计数器跟踪有多少线程“固定”了该页面。您的缓冲池管理器不能释放一个被固定的页面。每个 Page 对象还跟踪它是否是脏的。您的缓冲池管理器必须在 Page 对象被取消固定之前，将脏页面的内容写回到磁盘。

### NewPage

1.首先在free_list_空闲内存页中找有没有空闲的，如果有那么就将该页设置为当前页ID，没有的话看free_list_中有没有可以替换的，没有直接返回，
并设置page = pages_ + frame_id;2.物理页为，起始位置加上内存页ID，偏移量。page地址上原frame里存放的从内存中拿出的page_id对应的页是脏的，page->IsDirty()
，将其写回到磁盘中3.获取一个新的页面ID，把旧的映射删掉，建立新的映射4. 更新replacer_

### FlushPage
1.加锁2.无效或不存在的page_id直接返回失败3.获得page_id在缓冲池中的位置4.写回，这里creatpromise方法返回了一个std::promise对象5.赃位恢复

### DeletePage

给定物理页id，将物理页对应的frame从buffer中删除,如果页面存在，判断该页pin_count是不是为0，不为0，返回失败，否则 删除页面，且
将内存页加入空闲列表，替换器移除内存页ID，把内存该清的清，page的参数该换的换，调用DeallocatePage()来模仿在磁盘上释放页面

### FetchPage

给定物理页id，获取该物理页所对应的物理页

查找是否存在page_id，存在就找到物理页，通过page_id找到frame_id,然后更新replacer，返回该物理页，没找到的话，通过空闲内存页找一个内存页id，
找到对应的物理页， page = pages_ + frame_id;没有空闲，驱逐一个，该页脏的话将写入请求加入请求队列，删除原本的映射关系，加入新的映射关系
设置新找到的物理页个属性，更新replacer_，从磁盘中读页，读完后写回（之前的是写完后写回）

auto promise = disk_scheduler_->CreatePromise();

auto future = promise.get_future();

disk_scheduler_->Schedule({false, page->GetData(), page->GetPageId(), std::move(promise)});

future.get();

return page;


## DeBug 
/home/llb/CMU-15445-2023fall-Rewritten-version-/test/buffer/lru_k_replacer_test.cpp:45: Failure
Expected equality of these values:
2
value
Which is: 32
根据提示发现Evict出了问题，判断历史访问记录大小没有运行，原因LRUK_node节点的k_为0

